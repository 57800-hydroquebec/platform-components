global:
  dynamic:
    # -- Array of YAML files listing dynamic plugins to include with those listed in the `plugins` field.
    # Relative paths are resolved from the working directory of the initContainer that will install the plugins (`/opt/app-root/src`).
    includes:
      # -- List of dynamic plugins included inside the `janus-idp/backstage-showcase` container image, some of which are disabled by default.
      # This file ONLY works with the `janus-idp/backstage-showcase` container image.
      - 'dynamic-plugins.default.yaml'

    # -- List of dynamic plugins, possibly overriding the plugins listed in `includes` files.
    # Every item defines the plugin `package` as a [NPM package spec](https://docs.npmjs.com/cli/v10/using-npm/package-spec),
    # an optional `pluginConfig` with plugin-specific backstage configuration, and an optional `disabled` flag to disable/enable a plugin
    # listed in `includes` files. It also includes an `integrity` field that is used to verify the plugin package [integrity](https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description).
    plugins:
      - package: ./dynamic-plugins/dist/janus-idp-backstage-plugin-keycloak-backend-dynamic
        disabled: false
      - package: ./dynamic-plugins/dist/k-phoen-backstage-plugin-confluence-backend-dynamic
        disabled: false
        pluginConfig:
          confluence:
            wikiUrl: ${CONFLUENCE_URL}
            spaces: [ENG]
            auth:
              username: ${CONFLUENCE_USERNAME}
              password: ${CONFLUENCE_PASSWORD}
            schedule:
              frequency: { minutes: 2 }
              timeout: { minutes: 1 }
              initialDelay: { seconds: 3 }
      - package: ./dynamic-plugins/dist/microcks-backstage-plugin-provider-dynamic
        disabled: false
        pluginConfig:
          catalog:
            providers:
              microcksApiEntity:
                dev:
                  baseUrl: ${MICROCKS_BASE_URL}
                  serviceAccount: ${MICROCKS_SERVICE_ACCOUNT}
                  serviceAccountCredentials: ${MICROCKS_SERVICE_ACCOUNT_CREDS}
                  systemLabel: domain
                  ownerLabel: team 
                  addLabels: false
                  addOpenAPIServerUrl: true
                  schedule:
                    frequency: { minutes: 2 }
                    timeout: { minutes: 1 } 
      - package: ./dynamic-plugins/dist/backstage-plugin-scaffolder-backend-module-yeoman-dynamic
        disabled: false
      - package: ./dynamic-plugins/dist/backstage-plugin-catalog-backend-module-msgraph-dynamic
        disabled: false
        pluginConfig:
          catalog:
            providers:
              microsoftGraphOrg:
                default:
                  tenantId: ${MSGRAPH_TENANTID}
                  #user:
                  #  filter: accountEnabled eq true and userType eq 'member'
                  #group:
                  #  filter: >
                  #    securityEnabled eq false
                  #    and mailEnabled eq true
                  #    and groupTypes/any(c:c+eq+'Unified')
                  schedule:
                    frequency: { minutes: 15 }
                    timeout: { minutes: 1 }
                    initialDelay: { seconds: 15 }
      - package: ./dynamic-plugins/dist/backstage-plugin-catalog-backend-module-bitbucket-server-dynamic
        disabled: false
        pluginConfig:
          catalog:
            providers:
              bitbucketServer:
                systemEntities:
                  host: ${BITBUCKET_SERVER_HOST}
                  catalogPath: /catalog-info.yaml # default value
                  # filters: # optional
                  #   projectKey: '^apis-.*$' # optional; RegExp
                  #   repoSlug: '^service-.*$' # optional; RegExp
                  schedule:
                    frequency: { minutes: 5 }
                    timeout: { minutes: 2 }
                    initialDelay: { seconds: 15 }
          integrations:
            bitbucketServer:
            - host: ${BITBUCKET_SERVER_HOST}
              apiBaseUrl: https://${BITBUCKET_SERVER_HOST}/rest/api/1.0
              username: ${BITBUCKET_USERNAME}
              password: ${BITBUCKET_PASSWORD}

  # -- Shorthand for users who do not want to specify a custom HOSTNAME. Used ONLY with the DEFAULT upstream.backstage.appConfig value and with OCP Route enabled.
  clusterRouterBase: app.example.com
  # -- Custom hostname shorthand, overrides `global.clusterRouterBase`, `upstream.ingress.host`, `route.host`, and url values in `upstream.backstage.appConfig`
  host: ""
  auth:
    # -- Backend service to service authentication
    # <br /> Ref: https://backstage.io/docs/auth/service-to-service-auth/
    backend:
      # -- Enable backend service to service authentication, unless configured otherwise it generates a secret value
      enabled: true
      # -- Instead of generating a secret value, refer to existing secret
      existingSecret: ""
      # -- Instead of generating a secret value, use fo;lowing value
      value: ""
  keycloak:
    prefixBaseUrl: "https://keycloak-keycloak."
    backstageClient:
      id: "backstage"
      secret: my-secret
      oidcIssuerUrlSuffix: "/auth/realms/backstage"

# -- Upstream Backstage [chart configuration](https://github.com/backstage/charts/blob/main/charts/backstage/values.yaml)
# @default -- Use Openshift compatible settings
upstream:
  nameOverride: backstage
  backstage:
    image:
      registry: image-registry.openshift-image-registry.svc:5000
      repository: developer-hub/backstage-showcase
      tag: latest
    command: []
    # FIXME (tumido): USE POSTGRES_PASSWORD and POSTGRES_USER instead of POSTGRES_ADMIN_PASSWORD
    # This is a hack. In {fedora,rhel}/postgresql images, regular user is forbidden
    # from creating DBs in runtime. A single DB can be created ahead of time via
    # POSTGRESQL_DATABASE env variable (in this case via
    # upstream.postgresql.primary.extraEnvVars value), but this doesn't allow us to
    # create multiple DBs. Since Backstage requires by default 5 different DBs, we
    # can't accommodate that properly.
    appConfig:
      app:
        # Please update to match host in case you don't want to configure hostname via `global.clusterRouterBase` or `global.host`.
        baseUrl: 'https://{{- include "janus-idp.hostname" . }}'

      backend:
        baseUrl: 'https://{{- include "janus-idp.hostname" . }}'
        cors:
          origin: 'https://{{- include "janus-idp.hostname" . }}'
        database:
          client: pg
          connection:
            password: ${POSTGRESQL_ADMIN_PASSWORD}
            user: postgres
            host: "{{ .Release.Name }}-db-postgresql" #Matches with the host of the deployed postgresql instance
            port: 5432
            ssl:
              ca: ${CA_CERT}
              require: true
              rejectUnauthorized: true
        auth:
          keys:
            - secret: ${BACKEND_SECRET}

      integrations:
        github:
          - host: github.com
            token: ${GITHUB_TOKEN}

      catalog:
        import:
          entityFilename: catalog-info.yaml
          pullRequestBranchName: backstage-integration
        rules:
          - allow: [Component, System, Group, Resource, Location, Template, API]
        locations:
          - type: url
            target: https://github.com/janus-idp/backstage-showcase/blob/main/catalog-entities/all.yaml
          - type: url
            target: https://github.com/janus-api-idp/software-templates/blob/main/template-index.yaml
        providers:
          keycloakOrg:
            default:
              baseUrl: "{{ .Values.global.keycloak.prefixBaseUrl }}{{ .Values.global.clusterRouterBase }}/auth"
              loginRealm: "{{ .Values.global.keycloak.backstageClient.id }}"
              realm: "{{ .Values.global.keycloak.backstageClient.id }}"
              clientId: "{{ .Values.global.keycloak.backstageClient.id }}"
              clientSecret: "{{ .Values.global.keycloak.backstageClient.secret }}"
              schedule:
                frequency: { minutes: 1 }
                timeout: { minutes: 1 }
                initialDelay: { seconds: 15 }
          github:
            systems:
              organization: 'janus-api-idp' # string
              catalogPath: '/systems/*.yaml' # string
              filters:
                branch: 'main' # string
                repository: 'demo-systems' # Regex
              schedule: # optional
                frequency: { minutes: 1 }
                timeout: { minutes: 1 }
                initialDelay: { seconds: 15 }
            systemEntities:
              organization: 'janus-api-idp' # string
              catalogPath: '/catalog-info.yaml' # string
              filters:
                branch: 'master' # string
                repository: '.*' # Regex
              schedule: # optional
                frequency: { minutes: 1 }
                timeout: { minutes: 1 }
                initialDelay: { seconds: 15 }
      auth:
        environment: production
        providers:
          oauth2Proxy: {}
      signInPage: oauth2Proxy
      enabled:
        github: true
        keycloak: true
    readinessProbe:
      failureThreshold: 3
      httpGet:
        path: /healthcheck
        port: 7007
        scheme: HTTP
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 2
      timeoutSeconds: 2
    livenessProbe:
      failureThreshold: 3
      httpGet:
        path: /healthcheck
        port: 7007
        scheme: HTTP
      initialDelaySeconds: 60
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 2
    extraEnvVars:
    - name: BACKEND_SECRET
      valueFrom:
        secretKeyRef:
          key: backend-secret
          name: '{{ include "janus-idp.backend-secret-name" $ }}'
    - name: POSTGRESQL_ADMIN_PASSWORD
      valueFrom:
        secretKeyRef:
          key: postgres-password
          name: "{{ .Release.Name }}-db-postgresql"
    - name: GITHUB_TOKEN
      valueFrom:
        secretKeyRef:
          key: token
          name: "{{ .Release.Name }}-git-auth"
    - name: CA_CERT
      valueFrom:
        secretKeyRef:
          key: ca.crt
          name: "{{ .Release.Name }}-db-postgresql-tls" # Should match with the name of the secret where the CA for the postgresql server is stored
    - name: CONFLUENCE_URL
      value: changeme
    - name: CONFLUENCE_USERNAME
      value: changeme
    - name: CONFLUENCE_PASSWORD
      value: changeme
    - name: MSGRAPH_TENANTID
      value: changeme
    - name: MICROCKS_BASE_URL
      value: changeme
    - name: MICROCKS_SERVICE_ACCOUNT
      value: changeme
    - name: MICROCKS_SERVICE_ACCOUNT_CREDS
      value: changeme
    - name: BITBUCKET_SERVER_HOST
      value: changeme
    - name: BITBUCKET_USERNAME
      value: changeme
    - name: BITBUCKET_PASSWORD
      value: changeme
    args:
      # This additional `app-config`` file is generated by the initContainer below, and contains the merged configuration of installed dynamic plugins.
      - '--config'
      - dynamic-plugins-root/app-config.dynamic-plugins.yaml
    extraVolumeMounts:
      # The initContainer below will install dynamic plugins in this volume mount.
      - name: dynamic-plugins-root
        mountPath: /opt/app-root/src/dynamic-plugins-root
    extraVolumes:
      # -- Ephemeral volume that will contain the dynamic plugins installed by the initContainer below at start.
      - name: dynamic-plugins-root
        ephemeral:
          volumeClaimTemplate:
            spec:
              accessModes:
                - ReadWriteOnce
              resources:
                requests:
                  # -- Size of the volume that will contain the dynamic plugins. It should be large enough to contain all the plugins.
                  storage: 1Gi
      # Volume that will expose the `dynamic-plugins.yaml` file from the `dynamic-plugins` config map.
      # The `dynamic-plugins` config map is created by the helm chart from the content of the `global.dynamic` field.
      - name: dynamic-plugins
        configMap:
          defaultMode: 420
          name: dynamic-plugins
          optional: true
      # Optional volume that allows exposing the `.npmrc` file (through a `dynamic-plugins-npmrc` secret)
      # to be used when running `npm pack` during the dynamic plugins installation by the initContainer.
      - name: dynamic-plugins-npmrc
        secret:
          defaultMode: 420
          optional: true
          secretName: dynamic-plugins-npmrc
    initContainers:
      - name: install-dynamic-plugins
        # -- Image used by the initContainer to install dynamic plugins into the `dynamic-plugins-root` volume mount.
        # It could be replaced by a custom image based on this one.
        # @default -- `quay.io/janus-idp/backstage-showcase:latest`
        image: 'image-registry.openshift-image-registry.svc:5000/developer-hub/backstage-showcase:latest'
        command:
          - ./install-dynamic-plugins.sh
          - /dynamic-plugins-root
        env:
          - name: NPM_CONFIG_USERCONFIG
            value: /opt/app-root/src/.npmrc.dynamic-plugins
        imagePullPolicy: Always
        volumeMounts:
          - mountPath: /dynamic-plugins-root
            name: dynamic-plugins-root
          - mountPath: /opt/app-root/src/dynamic-plugins.yaml
            name: dynamic-plugins
            readOnly: true
            subPath: dynamic-plugins.yaml
          - mountPath: /opt/app-root/src/.npmrc.dynamic-plugins
            name: dynamic-plugins-npmrc
            readOnly: true
            subPath: .npmrc
        workingDir: /opt/app-root/src
    installDir: /opt/app-root/src
    podAnnotations:
      checksum/dynamic-plugins: >-
        {{- include "common.tplvalues.render" ( dict "value"
        .Values.global.dynamic "context" $) | sha256sum }}
    extraContainers:
    - name: "oauth2-proxy"
      env:
        - name: OAUTH2_PROXY_CLIENT_ID
          value: "{{ .Values.global.keycloak.backstageClient.id }}"
        - name: OAUTH2_PROXY_CLIENT_SECRET
          value: "{{ .Values.global.keycloak.backstageClient.secret }}"
        - name: OAUTH2_PROXY_COOKIE_SECRET
          value: 'fksdZJWUhzlfGw3Ve6POYc2jmjZogjCh'
        - name: OAUTH2_PROXY_OIDC_ISSUER_URL
          value: "{{ .Values.global.keycloak.prefixBaseUrl }}{{ .Values.global.clusterRouterBase }}{{ .Values.global.keycloak.backstageClient.oidcIssuerUrlSuffix }}"
        - name: OAUTH2_PROXY_SSL_INSECURE_SKIP_VERIFY
          value: 'true'
      ports:
        - name: "oauth2-proxy"
          containerPort: 4180
          protocol: TCP
      imagePullPolicy: IfNotPresent
      image: "quay.io/oauth2-proxy/oauth2-proxy:latest"
      args:
        - '--provider=oidc'
        - '--email-domain=*'
        - '--upstream=http://localhost:7007'
        - '--http-address=0.0.0.0:4180'
        - '--skip-provider-button'

  service:
    ports:
      backend: 4180
      targetPort: oauth2-proxy

  postgresql:
    enabled: false #Disabled when using an external connection

  ingress:
    enabled: false

# -- OpenShift Route parameters
route:

  # -- Route specific annotations
  annotations: {}

  # -- Enable the creation of the route resource
  enabled: true

  # -- Set the host attribute to a custom value. If not set, OpenShift will generate it, please make sure to match your baseUrl
  host: "{{ .Values.global.host }}"

  # -- Path that the router watches for, to route traffic for to the service.
  path: "/"

  # -- Wildcard policy if any for the route. Currently only 'Subdomain' or 'None' is allowed.
  wildcardPolicy: None

  # -- Route TLS parameters
  # <br /> Ref: https://docs.openshift.com/container-platform/4.9/networking/routes/secured-routes.html
  tls:

    # -- Enable TLS configuration for the host defined at `route.host` parameter
    enabled: true

    # -- Specify TLS termination.
    termination: "edge"

    # -- Certificate contents
    certificate: ""

    # -- Key file contents
    key: ""

    # -- Cert authority certificate contents. Optional
    caCertificate: ""

    # -- Contents of the ca certificate of the final destination.
    # <br /> When using reencrypt termination this file should be provided in order to have routers use it for health checks on the secure connection. If this field is not specified, the router may provide its own destination CA and perform hostname validation using the short service name (service.namespace.svc), which allows infrastructure generated certificates to automatically verify.
    destinationCACertificate: ""

    # --  Indicates the desired behavior for insecure connections to a route.
    # <br /> While each router may make its own decisions on which ports to expose, this is normally port 80. The only valid values are None, Redirect, or empty for disabled.
    insecureEdgeTerminationPolicy: "Redirect"

github:
  token: changeme
